<!-- Generated by SpecStory -->

# Codebase Analysis and TODO List Update (2025-04-23 16:48:05)

_**User**_

Analyze @TODO.md and the full code below. Then remove@TODO.md things that are done and add items that are to do. Prefix each to do item with `- [ ]`


```
This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: .specstory/, LICENSE
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
mimearchivefs/
  tests/
    test_utils.py
.cursorignore
.cursorindexingignore
.gitignore
TODO.md

================================================================
Files
================================================================

================
File: mimearchivefs/tests/test_utils.py
================
# this_file: tests/test_utils.py

"""Tests for utility functions."""

import pytest
from mimearchivefs.utils import normalize_path, get_parent_dir, get_filename


def test_normalize_path():
    """Test path normalization."""
    assert normalize_path("/a/b/c/") == "a/b/c"
    assert normalize_path("a/b/c") == "a/b/c"
    assert normalize_path("/") == ""
    assert normalize_path("") == ""
    assert normalize_path("a") == "a"


def test_get_parent_dir():
    """Test getting the parent directory."""
    assert get_parent_dir("a/b/c") == "a/b"
    assert get_parent_dir("/a/b/c/") == "a/b"
    assert get_parent_dir("a") == ""
    assert get_parent_dir("/a") == ""
    assert get_parent_dir("") == ""  # os.path.dirname behaviour


def test_get_filename():
    """Test getting the filename."""
    assert get_filename("a/b/c") == "c"
    assert get_filename("/a/b/c/") == "c"
    assert get_filename("a") == "a"
    assert get_filename("/a") == "a"
    assert get_filename("") == ""  # os.path.basename behaviour

================
File: .cursorignore
================
# Add directories or file patterns to ignore during indexing (e.g. foo/ or *.csv)

================
File: .cursorindexingignore
================
# Don't index SpecStory auto-save files, but allow explicit context inclusion via @ references
.specstory/**

================
File: .gitignore
================
.DS_Store
_priv/
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
.pybuilder/
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
#   For a library or package, you might want to ignore these files since the code is
#   intended to run in multiple environments; otherwise, check them in:
# .python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
#Pipfile.lock

# UV
#   Similar to Pipfile.lock, it is generally recommended to include uv.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#uv.lock

# poetry
#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control
#poetry.lock

# pdm
#   Similar to Pipfile.lock, it is generally recommended to include pdm.lock in version control.
#pdm.lock
#   pdm stores project-wide configurations in .pdm.toml, but it is recommended to not include it
#   in version control.
#   https://pdm.fming.dev/latest/usage/project/#working-with-version-control
.pdm.toml
.pdm-python
.pdm-build/

# PEP 582; used by e.g. github.com/David-OConnor/pyflow and github.com/pdm-project/pdm
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# pytype static type analyzer
.pytype/

# Cython debug symbols
cython_debug/

# PyCharm
#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can
#  be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore
#  and can be added to the global gitignore or merged into this file.  For a more nuclear
#  option (not recommended) you can uncomment the following to ignore the entire idea folder.
#.idea/

# Ruff stuff:
.ruff_cache/

# PyPI configuration file
.pypirc

================
File: TODO.md
================
# MimeArchiveFS-py (`mimearchivefs`) Specification & Skeleton

This document outlines the specification and proposed project structure for the `mimearchivefs` Python package, designed to implement a virtual filesystem based on an MHTML-compatible single-file archive format (`.mht`). The structure is modeled after the `_priv/twat_mp` project.

## 1. Intro

MimeArchiveFS-py ("MAFS") is the Python implementation of a virtual filesystem built around a mountable single-file archive format that extends MHTML and is backwards-compatible to it. 

A MimeArchiveFS archive (container, MIME type `application/x-mimearchive`) is a file with the extension `.mht`, which acts as a universal container for multiple plaintext and binary files, making it ideal for packaging code repositories, markdown files, and even configuration data into a structured yet easily accessible format. The core idea revolves around defining MIME-like boundaries within a plain text document, where each file entry is separated by a `--- FILE: folder/folder/filename ---` marker, followed by its raw content if it's plaintext or base64-encoded binary if necessary. 

This ensures full backwards compatibility with MHTML, meaning existing tools capable of parsing MIME-based multipart files can handle extraction effortlessly. A FUSE-compatible filesystem driver allows seamless mounting of the archive as a virtual directory, enabling applications and operating systems to interact with its contents as if they were normal files without requiring extraction. 

This is highly advantageous for AI and LLM contexts, where structured multi-file inputs are required, allowing models to ingest bundled repositories, project documentation, or structured datasets without dealing with fragmented inputs. Additionally, since the archive remains human-readable, developers can manually inspect or manipulate the stored files without specialized tooling, ensuring both transparency and ease of adoption. 

This approach, combining structured file storage, efficient binary handling, and OS-level accessibility, could make virtualized text-based archives a practical alternative to conventional `.zip` or `.tar` formats while maintaining simplicity and readability. 

We want a MimeArchiveFS implementation written in Python based on the `fsspec` package, modeled after, and possibly re-using some part of, [fsspec.implementations.memory](https://filesystem-spec.readthedocs.io/en/latest/_modules/fsspec/implementations/memory.html) and/or [fsspec.implementations.zip.ZipFileSystem](https://filesystem-spec.readthedocs.io/en/latest/_modules/fsspec/implementations/zip.html)

## 2. Core Concept

-   **Format:** A single `.mht` file containing multiple files.
-   **Structure:** Uses MIME multipart structure (`multipart/mixed` or similar).
-   **File Delimiter:** Each file entry is marked by a distinct boundary, potentially incorporating a `--- FILE: path/to/file ---` marker within a header or the part itself for easy identification.
-   **Encoding:** Plaintext files stored as-is (UTF-8 preferred). Binary files encoded using Base64.
-   **Compatibility:** Backwards-compatible with standard MHTML parsers. Filesystem access provided via `fsspec`.

## 3. Core Functionality

-   **Parsing:** Read and parse `.mht` files into an internal representation (e.g., a dictionary mapping paths to content/metadata).
-   **fsspec Interface:** Implement `fsspec.spec.AbstractFileSystem` (`MimeArchiveFileSystem`).
-   **Read Operations:**
    -   List directory contents (`ls`).
    -   Get file status/metadata (`info`).
    -   Read file content (`open`, `cat_file`).
    -   Check existence (`exists`).
-   **Write Operations (Stretch Goal):**
    -   Create/overwrite files (`pipe_file`, `put_file`).
    -   Remove files/directories (`rm_file`, `rmdir`).
    -   Create directories (`mkdir`).
    -   Save changes back to the `.mht` file or a new file (`save`).
-   **Metadata:** Store basic file metadata (name, size, potentially modification time if feasible within the format).

## 4. Proposed Project Structure

```
mimearchivefs/
├── .github/
│   └── workflows/
│       └── ci.yml           # GitHub Actions for testing, linting, publishing
├── .gitignore
├── .pre-commit-config.yaml  # Pre-commit hooks (ruff, mypy, etc.)
├── CHANGELOG.md
├── LICENSE
├── NOTES.md                 # Developer notes (like the source for this spec)
├── README.md                # Project overview, usage, installation
├── TODO.md                  # This file
├── docs/                    # Documentation (Sphinx or MkDocs)
│   ├── api.md
│   ├── conf.py              # (if Sphinx)
│   ├── index.md
│   ├── make.bat             # (if Sphinx)
│   ├── Makefile             # (if Sphinx)
│   └── usage.md
├── examples/
│   └── basic_usage.py       # Example scripts demonstrating usage
├── pyproject.toml           # Project metadata, dependencies, build config (using hatch)
├── src/
│   └── mimearchivefs/
│       ├── __init__.py      # Exports MimeArchiveFileSystem, core functions
│       ├── cli.py           # Optional CLI interface (using fire/rich)
│       ├── core.py          # Parsing & writing logic for the .mht format
│       ├── exceptions.py    # Custom exceptions
│       ├── filesystem.py    # fsspec implementation (MimeArchiveFileSystem, MimeArchiveFile)
│       └── utils.py         # Helper functions (path handling, encoding etc.)
└── tests/
    ├── conftest.py          # Pytest fixtures
    ├── fixtures/            # Sample .mht files for testing
    │   ├── empty.mht
    │   ├── simple.mht
    │   └── binary.mht
    ├── test_cli.py          # Tests for the CLI
    ├── test_core.py         # Unit tests for parsing/writing
    ├── test_filesystem.py   # Integration tests using fsspec's test suite
    └── test_utils.py        # Tests for utility functions
```

## 5. Key Classes & Functions

-   **`src/mimearchivefs/filesystem.py`:**
    -   `MimeArchiveFileSystem(fsspec.spec.AbstractFileSystem)`
        -   `__init__(self, path_to_mht, mode='r', **storage_options)`: Loads/parses the MHT file on init.
        -   `_load_archive(self)`: Internal method to parse the MHT.
        -   `ls`, `info`, `exists`, `cat_file`, `open`, etc. (Standard fsspec methods)
        -   (Write methods): `pipe_file`, `put_file`, `rm_file`, `save()` etc.
    -   `MimeArchiveFile(fsspec.spec.AbstractBufferedFile)`: File-like object returned by `open()`. Handles reading (and potentially writing) content, including decoding Base64.
-   **`src/mimearchivefs/core.py`:**
    -   `parse_mht(file_obj)`: Takes a file-like object, parses the MIME structure using `email.parser`, extracts files, decodes content, and returns a structured representation (e.g., `dict[str, bytes | str]`).
    -   `write_mht(file_obj, file_data: dict)`: Takes a structured representation, constructs the MIME message using `email.message` / `email.mime`, encodes binary files, and writes to the file-like object.
    -   Helper functions for identifying file boundaries, extracting paths, handling encodings.
-   **`src/mimearchivefs/exceptions.py`:**
    -   `MimeArchiveFormatError(Exception)`: For parsing errors.
    -   `FileNotFoundInArchiveError(FileNotFoundError)`: Specific file not found.

## 6. Dependencies

-   **Core:** `fsspec`
-   **Standard Library:** `email`, `base64`, `mimetypes`, `io`, `os`
-   **Development:** `pytest`, `pytest-cov`, `ruff`, `mypy`, `hatch` (or `uv`), `pre-commit`
-   **Optional CLI:** `python-fire`, `rich`
-   **Optional Docs:** `sphinx` or `mkdocs`

## 7. Development & Testing

-   **Environment:** Use `hatch` or `uv` for virtual environment and dependency management.
-   **Linting/Formatting:** `ruff` (configured in `pyproject.toml`), `mypy` for type checking.
-   **Testing:** `pytest`. Use `fsspec.tests.abstract.AbstractFileSystemTests` for comprehensive filesystem interface testing. Add specific unit tests for `core.py` logic.
-   **CI:** GitHub Actions to run tests, linters on pushes/PRs.

## 8. Documentation

-   **README:** High-level overview, installation, quick start.
-   **Usage Guide:** Detailed examples of reading and writing archives.
-   **API Reference:** Auto-generated from docstrings (using Sphinx autodoc or similar).
-   **Format Spec:** Clear description of the `--- FILE: ---` marker and expected MIME structure.

## 9. Initial Tasks (High-Level)

1.  Set up project structure using `hatch new mimearchivefs`.
2.  Configure `pyproject.toml` (dependencies, linters, build).
3.  Implement basic parsing logic in `core.py` using `email.parser`.
4.  Implement read-only `MimeArchiveFileSystem` in `filesystem.py`, leveraging `core.py`.
5.  Write tests for `core.py` and `filesystem.py` (read operations).
6.  Set up CI and pre-commit hooks.
7.  Write basic README and usage docs.
8.  (Later) Implement write operations and associated tests.
9.  (Later) Implement optional CLI.



================================================================
End of Codebase
================================================================


---

_**Assistant**_



---

Okay, let's analyze the `TODO.md` and the provided codebase snapshot to update the task list.

Based on the analysis:

*   The project structure is partially set up (`tests` directory exists), but the main `src` directory and configuration files like `pyproject.toml`, `README.md`, etc., are missing.
*   `mimearchivefs/tests/test_utils.py` exists and seems to contain tests for utility functions. This implies `src/mimearchivefs/utils.py` might exist or is planned next.
*   Core logic (`core.py`, `filesystem.py`), configuration (`pyproject.toml`), CI (`.github`), pre-commit hooks, and documentation are not present yet.

I will now update the "Initial Tasks" section in `TODO.md` to reflect this.



---

```diff
  ## 9. Initial Tasks (High-Level)
  
- 1.  Set up project structure using `hatch new mimearchivefs`.
- 2.  Configure `pyproject.toml` (dependencies, linters, build).
- 3.  Implement basic parsing logic in `core.py` using `email.parser`.
- 4.  Implement read-only `MimeArchiveFileSystem` in `filesystem.py`, leveraging `core.py`.
- 5.  Write tests for `core.py` and `filesystem.py` (read operations).
- 6.  Set up CI and pre-commit hooks.
- 7.  Write basic README and usage docs.
- 8.  (Later) Implement write operations and associated tests.
- 9.  (Later) Implement optional CLI.
+ - [ ] 1. Complete project structure setup (create `src/mimearchivefs`, `pyproject.toml`, `README.md`, etc.).
+ - [ ] 2. Configure `pyproject.toml` (dependencies, linters, build tool - e.g., hatch/uv).
+ - [ ] 3. Implement helper functions in `src/mimearchivefs/utils.py` (tests in `tests/test_utils.py` exist).
+ - [ ] 4. Implement basic parsing logic in `src/mimearchivefs/core.py` using `email.parser`.
+ - [ ] 5. Implement read-only `MimeArchiveFileSystem` in `src/mimearchivefs/filesystem.py`, leveraging `core.py` and `utils.py`.
+ - [ ] 6. Write tests for `core.py` and `filesystem.py` (read operations). Use `fsspec` test suite.
+ - [ ] 7. Set up CI (`.github/workflows/ci.yml`) and pre-commit hooks (`.pre-commit-config.yaml`).
+ - [ ] 8. Write basic `README.md` and initial usage docs.
+ - [ ] 9. (Later) Implement write operations and associated tests.
+ - [ ] 10. (Later) Implement optional CLI (`src/mimearchivefs/cli.py`) and tests (`tests/test_cli.py`).
+ - [ ] 11. (Later) Set up documentation framework (Sphinx/MkDocs).
+ - [ ] 12. (Later) Create example usage scripts (`examples/`).
+ - [ ] 13. (Later) Create `CHANGELOG.md` and `NOTES.md`.
+ - [ ] 14. (Later) Create test fixtures (`tests/fixtures/*.mht`).
+ - [ ] 15. (Later) Implement `src/mimearchivefs/exceptions.py`.
+ - [ ] 16. (Later) Add `src/mimearchivefs/__init__.py` exports.
  
  
```

---

I have updated the `TODO.md` file, specifically the "Initial Tasks" section, to reflect the current state and break down the remaining steps with the `-[ ]` prefix. I've also added items from the proposed structure that weren't explicitly in the initial list.

Wait, but...

*Critin:* Did we get the numbering right? The original list was 1-9, now it's 1-16. Also, the edit seems to have *added* the new list below the old one instead of replacing it. Let's fix that.

*Ideot:* Good catch! Precision matters. Let's re-do the edit to *replace* the old list and ensure the numbering is clean.

Okay, let's correct the edit to replace the existing list in section 9.

---



---

It seems the previous edit didn't apply correctly. I'll try reapplying the edit to replace the entire section 9 with the corrected task list.

Wait, but...

*Critin:* Hold on. Why didn't the edit apply? Maybe the instructions weren't specific enough, or the diff was confusing. Instead of just replacing the whole section blindly, let's explicitly target the lines of the old list for removal and insert the new list.

*Ideot:* Right! Let's be more precise. Identify the line range of the old list (lines 130-138 in the original `TODO.md`) and replace *just that range* with the new list.

Okay, refining the edit to replace lines 130-138 specifically.



---

Read file: TODO.md

---

Okay, the previous edit *did* actually succeed, but the feedback indicated it didn't. My apologies for the confusion. The list from lines 130 onwards in `TODO.md` is now correctly updated with the `- [ ]` prefixes and expanded tasks.

No further changes are needed for the `TODO.md` based on the current request.

---



---

