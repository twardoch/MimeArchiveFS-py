<!-- Generated by SpecStory -->

# Implementing TODO Tasks (2025-04-23 18:37:07)

_**User**_

Continue implementing the unimplemented @TODO.md 

---

_**Assistant**_



---

I'll start implementing the zipfile-like API to mimic Python's `zipfile` standard library, then move to the CLI implementation.

---

<details>
            <summary>Searched codebase "ziplike.py" â€¢ **0** results</summary>
        
No results found
</details>

---

Let me check if we already have a ziplike.py file in the project:

---

<details>
            <summary>Listed directory src/mimearchivefs â€¢ **5** results</summary>
        
| Name |
|-------|
| ðŸ“„ `exceptions.py` |
| ðŸ“„ `filesystem.py` |
| ðŸ“„ `core.py` |
| ðŸ“„ `__init__.py` |
| ðŸ“„ `utils.py` |

</details>

---

Let's examine the core.py and filesystem.py files to understand the current implementation:

---

Read file: src/mimearchivefs/core.py

---

Read file: src/mimearchivefs/filesystem.py

---

Read file: src/mimearchivefs/__init__.py

---

Now I'll implement the zipfile-like API by creating `src/mimearchivefs/ziplike.py`:

---

```diff
- 
+ #!/usr/bin/env python3
+ # this_file: src/mimearchivefs/ziplike.py
+ 
+ """ZipFile-like API for MimeArchiveFS."""
+ 
+ import io
+ import os
+ import time
+ from datetime import datetime
+ from typing import Any, Dict, List, Optional, Tuple, Union, BinaryIO, Iterator, cast
+ 
+ import mimearchivefs.core as core
+ import mimearchivefs.utils as utils
+ from mimearchivefs.exceptions import FileNotFoundInArchiveError
+ 
+ 
+ class MimeArchiveInfo:
+     """Class for storing information about a file in the MimeArchive."""
+ 
+     def __init__(
+         self,
+         filename: str,
+         date_time: Optional[Tuple[int, int, int, int, int, int]] = None,
+         compress_type: int = 0,
+         comment: str = "",
+         extra: bytes = b"",
+         create_system: int = 0,
+         file_size: int = 0,
+     ) -> None:
+         """
+         Initialize a MimeArchiveInfo instance.
+ 
+         Args:
+             filename: Path of the file inside the archive
+             date_time: File timestamp (year, month, day, hour, minute, second)
+             compress_type: Compression method (always 0 for MimeArchive)
+             comment: File comment
+             extra: Extra data
+             create_system: System that created the file
+             file_size: Size of the file in bytes
+         """
+         self.filename = utils.normalize_path(filename)
+         self.file_size = file_size
+ 
+         # Set date_time to current time if not provided
+         if date_time is None:
+             current_time = time.localtime()
+             self.date_time = (
+                 current_time.tm_year,
+                 current_time.tm_mon,
+                 current_time.tm_mday,
+                 current_time.tm_hour,
+                 current_time.tm_min,
+                 current_time.tm_sec,
+             )
+         else:
+             self.date_time = date_time
+ 
+         # MimeArchive doesn't use compression, but we store this for API compatibility
+         self.compress_type = compress_type
+         self.comment = comment
+         self.extra = extra
+         self.create_system = create_system
+         self.create_version = 20  # Version used to create the file (2.0)
+         self.extract_version = 20  # Version needed to extract the file
+         self.reserved = 0  # Reserved field
+         self.flag_bits = 0  # Flag bits
+         self.volume = 0  # Volume number
+         self.internal_attr = 0  # Internal file attributes
+         self.external_attr = 0  # External file attributes
+         self.header_offset = 0  # Header offset
+         self.CRC = 0  # CRC-32 of the file
+ 
+     @property
+     def compress_size(self) -> int:
+         """Get the compressed size (same as file_size for MimeArchive)."""
+         return self.file_size
+ 
+ 
+ class MimeArchive:
+     """
+     Class with interface similar to ZipFile for handling MimeArchive files.
+     """
+ 
+     def __init__(
+         self,
+         file: Union[str, BinaryIO],
+         mode: str = "r",
+         compression: int = 0,
+         allowZip64: bool = True,
+     ) -> None:
+         """
+         Initialize a MimeArchive instance.
+ 
+         Args:
+             file: Path to the file or a file-like object
+             mode: File mode ('r' for read, 'w' for write, 'a' for append)
+             compression: Always 0 for MimeArchive (parameter for ZipFile compatibility)
+             allowZip64: Not used, but included for ZipFile compatibility
+         """
+         self.filename = file if isinstance(file, str) else None
+         self.mode = mode
+         self.debug = 0  # Debug level
+         self.comment = b""  # Archive comment
+ 
+         # Initialize internal state
+         self._files: Dict[str, bytes] = {}
+         self._file_info: Dict[str, MimeArchiveInfo] = {}
+ 
+         # Open the file if needed
+         if mode == "r":
+             if isinstance(file, str):
+                 self._files = core.parse_mht(file)
+             else:
+                 self._files = core.parse_mht(file)
+ 
+             # Create file info objects
+             for path, content in self._files.items():
+                 self._file_info[path] = MimeArchiveInfo(
+                     filename=path,
+                     file_size=len(content),
+                 )
+         elif mode == "w":
+             # Start with an empty archive
+             pass
+         elif mode == "a":
+             # Append mode, first read the existing content
+             if isinstance(file, str):
+                 try:
+                     self._files = core.parse_mht(file)
+                     for path, content in self._files.items():
+                         self._file_info[path] = MimeArchiveInfo(
+                             filename=path,
+                             file_size=len(content),
+                         )
+                 except FileNotFoundError:
+                     # File doesn't exist, treat it as write mode
+                     pass
+             else:
+                 self._files = core.parse_mht(file)
+                 for path, content in self._files.items():
+                     self._file_info[path] = MimeArchiveInfo(
+                         filename=path,
+                         file_size=len(content),
+                     )
+         else:
+             raise ValueError(f"Invalid mode: {mode}")
+ 
+     def getinfo(self, name: str) -> MimeArchiveInfo:
+         """
+         Get information about a file in the archive.
+ 
+         Args:
+             name: Path of the file inside the archive
+ 
+         Returns:
+             MimeArchiveInfo object
+ 
+         Raises:
+             FileNotFoundInArchiveError: If the file is not found in the archive
+         """
+         path = utils.normalize_path(name)
+         if path not in self._file_info:
+             raise FileNotFoundInArchiveError(
+                 f"There is no file named '{name}' in the archive"
+             )
+         return self._file_info[path]
+ 
+     def infolist(self) -> List[MimeArchiveInfo]:
+         """
+         Get a list of MimeArchiveInfo objects for all files in the archive.
+ 
+         Returns:
+             List of MimeArchiveInfo objects
+         """
+         return list(self._file_info.values())
+ 
+     def namelist(self) -> List[str]:
+         """
+         Get a list of file names in the archive.
+ 
+         Returns:
+             List of file names
+         """
+         return list(self._files.keys())
+ 
+     def open(self, name: str, mode: str = "r") -> io.BytesIO:
+         """
+         Open a file in the archive.
+ 
+         Args:
+             name: Path of the file inside the archive
+             mode: File mode ('r' for read, 'w' for write)
+ 
+         Returns:
+             File-like object for reading or writing
+ 
+         Raises:
+             FileNotFoundInArchiveError: If the file is not found and mode is 'r'
+             ValueError: If an unsupported mode is specified
+         """
+         path = utils.normalize_path(name)
+ 
+         if mode.startswith("r"):
+             if path not in self._files:
+                 raise FileNotFoundInArchiveError(
+                     f"There is no file named '{name}' in the archive"
+                 )
+             return io.BytesIO(self._files[path])
+         elif mode.startswith("w"):
+             # Create an empty file for writing
+             buffer = io.BytesIO()
+             self._open_buffers[path] = buffer
+             return buffer
+         else:
+             raise ValueError(f"Unsupported mode: {mode}")
+ 
+     def read(self, name: str) -> bytes:
+         """
+         Read a file from the archive.
+ 
+         Args:
+             name: Path of the file inside the archive
+ 
+         Returns:
+             File contents as bytes
+ 
+         Raises:
+             FileNotFoundInArchiveError: If the file is not found in the archive
+         """
+         path = utils.normalize_path(name)
+         if path not in self._files:
+             raise FileNotFoundInArchiveError(
+                 f"There is no file named '{name}' in the archive"
+             )
+         return self._files[path]
+ 
+     def write(
+         self,
+         filename: str,
+         arcname: Optional[str] = None,
+         compress_type: Optional[int] = None,
+     ) -> None:
+         """
+         Write a file to the archive.
+ 
+         Args:
+             filename: Path to the file to add
+             arcname: Name to give the file in the archive
+             compress_type: Not used, included for ZipFile compatibility
+ 
+         Raises:
+             ValueError: If the archive is not in write or append mode
+         """
+         if self.mode not in ("w", "a"):
+             raise ValueError("write() requires mode 'w' or 'a'")
+ 
+         if arcname is None:
+             arcname = filename
+ 
+         arcname = utils.normalize_path(arcname)
+ 
+         # Read the file content
+         with open(filename, "rb") as f:
+             content = f.read()
+ 
+         # Add to the archive
+         self._files[arcname] = content
+         self._file_info[arcname] = MimeArchiveInfo(
+             filename=arcname,
+             file_size=len(content),
+         )
+ 
+     def writestr(
+         self,
+         zinfo_or_arcname: Union[str, MimeArchiveInfo],
+         data: Union[str, bytes],
+         compress_type: Optional[int] = None,
+     ) -> None:
+         """
+         Write a string or bytes to the archive.
+ 
+         Args:
+             zinfo_or_arcname: Archive name or MimeArchiveInfo instance
+             data: Content to write (string or bytes)
+             compress_type: Not used, included for ZipFile compatibility
+ 
+         Raises:
+             ValueError: If the archive is not in write or append mode
+         """
+         if self.mode not in ("w", "a"):
+             raise ValueError("writestr() requires mode 'w' or 'a'")
+ 
+         if isinstance(zinfo_or_arcname, MimeArchiveInfo):
+             arcname = zinfo_or_arcname.filename
+             zinfo = zinfo_or_arcname
+         else:
+             arcname = utils.normalize_path(zinfo_or_arcname)
+             zinfo = MimeArchiveInfo(filename=arcname)
+ 
+         # Convert string to bytes if needed
+         if isinstance(data, str):
+             data = data.encode("utf-8")
+ 
+         # Update zinfo
+         zinfo.file_size = len(data)
+ 
+         # Add to the archive
+         self._files[arcname] = data
+         self._file_info[arcname] = zinfo
+ 
+     def extract(
+         self, member: Union[str, MimeArchiveInfo], path: Optional[str] = None, pwd: Optional[bytes] = None
+     ) -> str:
+         """
+         Extract a member from the archive to the current working directory.
+ 
+         Args:
+             member: Member specification (filename or MimeArchiveInfo instance)
+             path: Directory to extract to (default is current directory)
+             pwd: Not used, included for ZipFile compatibility
+ 
+         Returns:
+             Path to the extracted file
+ 
+         Raises:
+             FileNotFoundInArchiveError: If the member is not found in the archive
+         """
+         if isinstance(member, MimeArchiveInfo):
+             name = member.filename
+         else:
+             name = member
+ 
+         # Normalize path
+         name = utils.normalize_path(name)
+ 
+         # Check if the file exists in the archive
+         if name not in self._files:
+             raise FileNotFoundInArchiveError(
+                 f"There is no file named '{name}' in the archive"
+             )
+ 
+         # Create directory structure
+         if path is None:
+             path = os.getcwd()
+         
+         target_path = os.path.join(path, name)
+         target_dir = os.path.dirname(target_path)
+         
+         if target_dir and not os.path.exists(target_dir):
+             os.makedirs(target_dir)
+ 
+         # Write the file
+         with open(target_path, "wb") as f:
+             f.write(self._files[name])
+ 
+         return target_path
+ 
+     def extractall(
+         self, path: Optional[str] = None, members: Optional[List[Union[str, MimeArchiveInfo]]] = None, pwd: Optional[bytes] = None
+     ) -> None:
+         """
+         Extract all members from the archive to the current working directory.
+ 
+         Args:
+             path: Directory to extract to (default is current directory)
+             members: List of members to extract (default is all)
+             pwd: Not used, included for ZipFile compatibility
+         """
+         if members is None:
+             members = self.namelist()
+         elif isinstance(members[0], MimeArchiveInfo) if members else False:
+             members = [cast(MimeArchiveInfo, m).filename for m in members]
+ 
+         for name in members:
+             self.extract(name, path, pwd)
+ 
+     def close(self) -> None:
+         """
+         Close the archive, writing any modified data to the original file.
+         """
+         if self.mode in ("w", "a") and self.filename is not None:
+             core.write_mht(self.filename, self._files)
+ 
+     def __enter__(self) -> "MimeArchive":
+         """Context manager entry."""
+         return self
+ 
+     def __exit__(self, exc_type: Any, exc_val: Any, exc_tb: Any) -> None:
+         """Context manager exit."""
+         self.close()
+ 
+     def printdir(self) -> None:
+         """Print a table of contents for the archive."""
+         print("File Name                                             Modified             Size")
+         for zinfo in self.infolist():
+             date = "%d-%02d-%02d %02d:%02d:%02d" % zinfo.date_time[:6]
+             print(f"{zinfo.filename:51} {date} {zinfo.file_size:12d}") 
```

---

Let me fix the linter errors in the ziplike.py file:

---

Cancelled

---



---



---

